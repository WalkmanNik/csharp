using ConsoleApp1;
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;

namespace ConsoleApp1
{
    /// <summary>
    /// Добро пожаловать в "краткий" экскурс по C#;
    /// Если вы ниче не поняли, то это уже ваши проблемы, а не мои;
    /// Данный файл был создан во время изучения курсов по C# с канала "#SimpleCode" и использовался как конспект;
    /// Если шарите в программировании, но не знаете C# - мне кажется, этого файла может хватит. Я не проверял;
    /// Если нет, то рекомендую перейти по ссылке и посмотреть весь курс:
    /// https://www.youtube.com/playlist?list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N
    /// Данный код не предназначен для запуска, а лишь только для изучения синтаксиса!
    /// </summary>
    internal class Program
    {
        static void Main(string[] args)
        {
            cheeseburger();
            // Вывод сообщения "Привет, мир!" в консоль;
            Console.WriteLine("Hello, world!");
            // По факту является обращением System.Console.WriteLine(string Value);
            // Но т.к. мы используем "using System" то "System." можно убрать;


            // --Типы переменных--

            // Особые;
            object ob = null; // "System.Object" | Базовый тип данных для всех типов данных, благодаря ему можно ссылаться на абсолютно разные типы данных;
            dynamic dn = null;

            // Целые числа;
            sbyte sb_min = sbyte.MinValue; sbyte sb_max = sbyte.MaxValue; // "System.SByte" | -128 -> 127 | 1 byte;
            byte b_min = byte.MinValue; byte b_max = byte.MaxValue; // "System.Byte" | 0 -> 255 | 1 byte;
            short s_min = short.MinValue; short s_max = short.MaxValue; // "System.Int16" | -32768 -> 32767 | 2 byte;
            ushort us_min = ushort.MinValue; ushort us_max = ushort.MaxValue; // "System.UInt16" | 0 -> 65535 | 2 byte;
            int i_min = int.MinValue; int i_max = int.MaxValue; // "System.Int32" | -2147483648 -> 2147483647 | 4 byte;
            uint ui_min = uint.MinValue; uint ui_max = uint.MaxValue; // "System.UInt32" | 0 -> 4294967295 | 4 byte;
            long l_min = long.MinValue; long l_max = long.MaxValue; // "System.Int64" | -9223372036854775808 -> 9223372036854775807 | 8 byte;
            ulong ul_min = ulong.MinValue; ulong ul_max = ulong.MaxValue; // "System.UInt64" | 0 -> 18446744073709551615 | 8 byte;

            // Числа с плавающей точкой;
            float fl_min = float.MinValue; float fl_max = float.MaxValue; // "System.Single" | -3.40282347E+38 -> 3.40282347E+38 | Точность 6-9 цифр | 4 byte;
            double db_min = double.MinValue; double db_max = double.MaxValue; // "System.Double" | -1.7976931348623157E+308 -> 1.7976931348623157E+308 | Точность 15-17 цифр | 8 byte;
            decimal dc_min = decimal.MinValue; decimal dc_max = decimal.MaxValue; // "System.Decimal" | оч_много -> оч_много | Точность 28-29 знаков | 16 byte;

            // Символы;
            char c = 'a'; // "System.Char" | Может содержать только один символ;
            string s = "Hello, world!"; // "System.String" | Может содержать полноценный текст;

            // Логика;
            bool bl = true; // "System.Boolean" | true/false, правда/ложь;

            // Ну и на закусочку, кстати;
            var bebey = 10; // <- благодаря "var" компилятор сам постарается понять, какой тип назначить для переменной;
                            // Но подробнее об этом будет ниже;


            // Пример того, как создается переменная:
            int new_int; // Создаем переменную и задаем её тип;
            new_int = 5; // Задаем переменной значение;


            // Можно задавать тип переменных последовательно как на примере ниже:
            int a, b; // <- Крутая фича;
            a = 5;
            b = 10;


            // Ввод данных из консоли и дальнейший вывод их в ту же консоль;
            Console.WriteLine("Введите ваше имя:");
            string name;
            name = Console.ReadLine(); // Собственно, ввод данных пользователем происходит именно здесь;
            Console.WriteLine("Добро пожаловать, " + name + "!");


            // Конвертация типа "string" в тип "int" и получение текущего года из даты;
            Console.WriteLine("Введите ваш возраст:");
            //int age = int.Parse(Console.ReadLine());
            Console.WriteLine("Ваш год рождения: {0}", (DateTime.Now.Year - Convert.ToInt32("32"))); // Да, можно и таким образом форматировать вывод;


            // Преобразование типа "string" в тип "double" в зависимости от локализации операционной системы;
            // Если нихрена не понятно, просто вернешься к этому позже;
            // Использование в дробных числах точки или запятой в некоторых регионах может отличаться;
            // В данном случае мы создаем формат и говорим функции Convert.ToDouble что нам нужна именно точка, а не запятая;
            string height = "1.90"; // Допустим, это рост в метрах с той самой точкой;

            //"using System.Globalization" сверху необходим как раз для этой строчки;
            NumberFormatInfo numberFormatInfo = new NumberFormatInfo()
            {
                NumberDecimalSeparator = ".",
            };
            double d_height = Convert.ToDouble(height, numberFormatInfo); // Конвертация будет завершена успешно, т.к. мы сказали конвертатору что нам нужна именно точка;


            // Использование парсинга (преобразования) не через конвертер, а через сами типы данных;
            string string_number = "9"; // Число в виде символа;
            int parsed_number = int.Parse(string_number); // "int" таким образом преобразовывает значение переменной типа "string" в самого себя, т.е. "int";
            double parsed_double = double.Parse("6,2"); // То же самое, только с "double";
            double parsed_double_with_dot = double.Parse("5.4", numberFormatInfo); // Используем переменную "numberFormatInfo" чтобы сказать преобразователю, что нам нужна точка;


            // Обработка недействительных значений при входе данных;
            // С помощью "try" и "catch" программа не будет завершена из-за ошибки, а просто выведет строку в консоль при неуспешной конвертации;
            string wtf = "25lol";
            try
            {
                int parsed_int = int.Parse(wtf);
                Console.WriteLine("Успешная конвертация!");
            }
            catch (Exception)
            {
                Console.WriteLine("Ошибка при конвертации!");
            }


            // Функция "TryParse" не может выдать ошибку при выполнении, т.к. при недействительном значении введенных данных просто не будет преобразовывать переменную;
            string wtf2 = "39rofl";
            int try_parse_number; // Если значение выше недействительно, здесь при преобразовании просто останется число 0 (см. ниже);

            int.TryParse(wtf2, out try_parse_number); // "out" означает, что при корректном выполнении функции мы преобразовывем переменную (см. выше);

            bool result = int.TryParse("39", out try_parse_number); // Эта функция также может выдавать true/false при успешной/неуспешной конвертации;
            if (result)
            {
                Console.WriteLine("Успешная конвертация!");
            }
            else
            {
                Console.WriteLine("Ошибка при конвертации!");
            }


            // --Бинарные операторы (работают с двумя операндами) и особенности работы с ними--

            int i1 = 2;
            int i2 = 5;
            int result4 = i1 / i2; // = 0 | т.к. нужен тип "double";
            double result5 = i1 / i2; // = 0 | т.к. оба числа типа "int";

            double i3 = 4;
            int i4 = 10;
            double result6 = i3 / i4; // = 0.4 | т.к. одно из чисел имеет тип "double";
            double result7 = i4 / i3; // = 2.5;
            double result8 = (double)i1 / i2; // = 0.4 | т.к. полученный результат сразу преобразовывается в "double";
            int result9 = 10 % 3; // = 1 | Деление с остатком;


            // --Унарные операторы (работают лишь с одним операндом) инкремента и декремента во всей своей красе--

            int n1 = 0;
            n1++; // = 1 | Увеличивает число на 1;
            Console.WriteLine(n1++); // = 1 | т.к. сначала идет вывод значение переменной "n" в консоль, а только потом число увеличится на 1;
            int m = 0;
            Console.WriteLine(++m); // = 1 | т.к. увеличение числа произойдет перед выводом в консоль;
            n1--; // Декремент, уменьшает число на 1;
            Console.WriteLine(n1);

            int n2 = 1;
            n2 = ++n2 * n2; // = 4 | т.к. (1 + 1) * (1 + 1) | Префиксный инкремент имеет наибольший приоритет при просчете;
            // Именно поэтому было сначала увеличено значение переменной "n2", а потом мы получили значение суммы уже увеличенных переменных;
            int n3 = 1;
            n3 = n3++ * n3; // = 2 | т.к. (1 * 1) + 1 | Постфиксный инкремент имеет наименьший приоритет при просчете;


            // --Операторы "if" и "else", ничего особенного--
            if (n3 > 1) // Если выполняется условие, т.е. мы получаем "true", то исполняется код ниже;
            {
                n3--;
            }
            else if (n3 < 2) // Если условие выше не было выполнено, но выполнено это условие, то исполняется код ниже;
            {
                n3 = 0;
            }
            else // Если же не было выполнено ни одно из условий, то исполняется код ниже;
            {
                n3++;
            }


            // --Оператор "switch"--
            int l = 4; // Задаем переменную;
            switch (l) // Скармливаем переменную оператору;
            {
                case 0: // "case <значение>" нужен для того, чтобы сравнить переменную "l" со своим значением;
                    Console.WriteLine("Это ноль без палочки. А нет, все же с палочкой.");
                    break; // Необходим для "закрытия" кейса;
                case 1:
                    {
                        Console.WriteLine("Это единица."); // Кейс можно закрыть скобками на случаей, если так будет удобнее;
                    }
                    break;
                case 4:
                    Console.WriteLine("ЧОТЫРИ!!!!!!");
                    break;
                case 5: // В данном случае мы оставляем кейс без "break" и логики, т.к. они находится под следующим кейсом;
                case 6:
                    Console.WriteLine("Это или пять, или шесть, кто его знает? Число Шрёдингера какое-то...");
                    break;
                default: // Выполняется если значение переменной не было найдено среди значений "кейсов". Аналог "else";
                    Console.WriteLine("Ты втираешь мне какую-то дичь!");
                    break;
            }

            string k = "Alexey"; // Также работает с типом "string";
            switch (k)
            {
                case "Alexey":
                    Console.WriteLine("Поздравляем, вы Alexey!");
                    break;
                case "Gregory": // Если один из кейсов имеет тип "string", то и все остальные кейсы должны иметь тот же тип для корректной работы;
                    Console.WriteLine("Соболезную, вы Gregory...");
                    break;
            }

            // --Цикл "while"--
            // Будет выполняться до тех пор, пока получает в себя значение "true";
            int count1 = 0;
            while (count1 < 5) // Сначала идет проверка условия, потом выполняется цикл;
            {
                Console.WriteLine(count1);
                count1++;
            } // В итоге мы получим числа 0, 1, 2, 3, 4;

            int count2 = 0;
            do // В данном случае сначала выполняется цикл, а уже потом идет проверка условия;
            {
                Console.WriteLine(count2);
                count2++;
            } while (count2 < 5); // В итоге мы получаем числа 0, 1, 2, 3, ;


            // --Цикл "for"--
            // Работает до тех пор, пока получает в себя значение "true", как и "while";
            // Однако имеет некоторые свои особенности;
            int length = 10;
            for (int i = 0; i < length; i++) // В данном случае переменная "i" не может выйти за рамки цикла;
            {
                Console.WriteLine(i);
            }

            int o = 0;
            for (; o > -10; o--) // Можно также пропустить введение внутренней переменной, однако наличие ";" обязательно для компилятора;
            {
                Console.WriteLine(o);
            }

            int u = 10;
            for (; u < 30;) // Можно пропустить преобразование переменной, однако наличие ";" обязательно;
            {
                Console.WriteLine(u);
                u++;
                System.Threading.Thread.Sleep(300); // Ожидаем 300 мс перед тем, как снова выполнять цикл;
            }

            for (; ; ) // Бесконечный цикл;
            {
                break; // Я пошутил, прервать его можно оператором "break";
            }

            for (int i = 0; ; i++) // Можно использовать самые разные вариации по мере необходимости;
            {
                if (i > 3)
                {
                    break; // Данный оператор прерывает ВЕСЬ цикл;
                }
            }

            for (int i = 0, j = 5; i < 10 && j < 12; i++, j++) // Можно объявлять и использовать сразу несколько переменных;
            {
                Console.WriteLine(i);
                Console.WriteLine(j);
            }

            for (int i = 0; i < 10; i++)
            {
                if (i == 5)
                {
                    continue; // Переходим на следующую итерацию цикла, пропуская число 5. Не прерывает весь цикл, только текущую итерацию;
                }
                Console.WriteLine(i);
            }


            // --Вложенные циклы--
            // Цикл внутри цикла, логично.
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("Цикл №1, итерация: {0}", i); // Сначала мы показываем переменную "i" 1 раз;
                for (int j = 0; j < 10; j++)
                {
                    Console.WriteLine("\tЦикл №2, итерация: {0}", j); // Потом показываем переменную "j" 10 раз и снова показываем "i" 1 раз, а потом "j" 10 раз... И так пока "i" не станет 10;
                }
            }

            for (int i = 0; i < 10; i++)
            {
                for (int j = 0; j < 20; j++)
                {
                    Console.Write("#"); // Просто добавляем один символ в консоль 20 раз;
                }
                Console.WriteLine(); // Переход на следующую линию, как только "#" будет отрисована 20 раз;
            } // Всего должно получиться 10 линий по 20 "#" в каждой;


            // --Тернарный оператор (работает с тремя операндами)--
            // [1й операнд - условие] ? [2й операнд - if_true] : [3й операнд - if_false];

            // Пример с избыточным кодом (как делать нежелательно):
            bool accessAllowed;
            string storedPassword = "qwerty";
            string enteredPassword = Console.ReadLine();

            if (enteredPassword == storedPassword)
            {
                accessAllowed = true;
            }
            else
            {
                accessAllowed = false;
            }
            Console.WriteLine(accessAllowed);

            // Пример с использованием тернарного оператора (как делать круто и модно);
            accessAllowed = enteredPassword == storedPassword ? true : false;
            Console.WriteLine(accessAllowed);

            // Еще один пример использования тернарного оператора;
            int inputData = int.Parse(Console.ReadLine()); // Запрашиваем число из консоли и парсим его в переменную типа "int";
            int outputData = inputData < 0 ? 0 : inputData; // Если число меньше 0, то выводим 0, если больше, то пишем введенное число без изменений;
            Console.WriteLine(outputData);


            // ---Массивы---

            // --Одномерные массивы--
            // тип_элементов_массива [] имя_массива;

            int[] int_array; // = null (отсутствует ссылка) | Создаем новый массив, который будет содержать элементы (переменные) типа "int";
            int_array = new int[10]; // Отводим место для массива в оперативной памяти, определяя размер массива, т.е. он будет содержать максимум 10 элементов;
                                     // Индексы массива будут выглядеть как [0], [1], [2], [3] и т.д.;

            int_array[0] = 5; // Вводим индекс в [] и потом задаем число;
            int_array[3] = 10; // В дальнейшем по индексам можно обращаться в массив для получения заданных значений;
            //int_array[16] = 4; -> выдаст ошибку, т.к. индекс выходит за рамки размеров массива;

            Console.WriteLine(int_array[3]); // Выводим число 10, которое задали ранее, обращаясь к массиву по индексу;
            int int_from_int_array = int_array[0]; // Создаем переменную и задаем ей значение 5 из массива;

            // --Инициализация массива--

            int[] new_array1 = new int[5] { 3, 4, 1, 7, 6 }; // Сразу инициализируем массив и вводим в него данные;
            // int[] new_array1 = new int[5] { 3, 4, 1, 7}; -> выдаст ошибку, т.к. не хватает пятого числа;
            int[] new_array2 = new int[] { 3, 4, 1, 7 }; // Можно не указывать размер для массива, и тогда он задаст его сам исходя из вводных данных;
            // int[] new_array2 = new int[]; -> выдаст ошибку, т.к. без вводных данных компилятор не может инициализировать массив, ибо не знает его размеров;
            int[] new_array3 = new[] { 5, 1, 3, 8 }; // Можно не указывать тип массива при инициализации, он возьмет его из вводных данных;
            // int[] new_array3 = new [5]; -> выдаст ошибку, т.к. не был определен тип и компилятор не понимает, под какой тип ему выделять память;
            int[] new_array4 = { 5, 1, 3, 8 }; // Можно не вводить "new[]", если тип и количество элементов можно определить из вводных данных;
            int[] new_array5 = Enumerable.Repeat(5, 10).ToArray(); // Добавляем число "5" в массив "new_array5" 10 раз. "ToArray()" необходим, чтобы преобразовать это все в массив;
            int[] new_array6 = Enumerable.Range(3, 5).ToArray(); // Начинает отсчет от числа "2", создает 5 элементов, т.е. вывод в итоге будет {3, 4, 5, 6, 7};

            // --Вывод массива--

            int[] my_array = { 4, 1, 5, 7, 6 };
            for (int i = 0; i < my_array.Length; i++) // Используем цикл "for", ограничивая число его итераций размером массива, который получаем при помощи "my_array.Length";
            {
                Console.WriteLine(i);
            } // В итоге в косноль будут выведены числа 4, 1, 5, 7, 6;
            int min_value_in_my_array = my_array.Min(); // Выводит минимальное число из массива, т.е. "1";
            int max_value_in_my_array = my_array.Max(); // Выводит максимальное число из массива, т.е. "7";
                                                        // При отсутствии "using System.Linq" функции "Min()" и "Max()" не будут работать!
            int sum_values_in_my_array = my_array.Sum(); // Выводит сумму всех чисел в массиве;
            Console.WriteLine(my_array.Where(i => i % 2 == 0).Sum()); // Выводит сумму только четных чисел, используя функцию "Where" и lamba-функцию;
                                                                      // "i % 2 == 0" здесь является условием выбора элементов массива, а потом из выбранных элементов мы получаем сумму; 
            Console.WriteLine(my_array.Where(i => i % 2 != 0).Min()); // Выводит наименьшее нечетное число из массива;
            int[] new_array7 = { 11, 16, 20, 11, 18, 4, 20 };
            int[] distincted_new_array7 = new_array7.Distinct().ToArray(); // Убираем повторяющиеся значения из массива;
            int[] ordered_new_array7 = new_array7.OrderBy(i => i).ToArray(); // Сортируем числа в массиве в порядке возрастания;
            int[] desс_ordered_new_array7 = new_array7.OrderByDescending(i => i).ToArray(); // Сортируем числа в массиве в порядке убывания;
            Array.Sort(my_array); // Сортируем "my_array" в порядке возрастания с помощью статической функции класса "Array", т.е. самого массива;
            int number_bubumber = Array.Find(my_array, i => i < 5); // Находит число ниже пяти и присваевает значение переменной;
                                                                    // Функция ищет число начиная с индекса [0] и до конца списка, возвращая первое же число, подпадающее под условия;
            int number_bubumber2 = Array.FindLast(my_array, i => i < 5); // Находит число ниже пяти, начиная с конца списка и идя до начала списка;
            int[] numbers_bubumbers = Array.FindAll(my_array, i => i < 5); // Находит все числа ниже пяти, и возвращает массив с ними;
            int number_bubumber3 = Array.FindIndex(my_array, i => i == 5); // Возвращает индекс находящегося в массиве числа, чтобы потом можно было получить его через "my_array[индекс]";
            int number_bubumber4 = Array.FindIndex(my_array, i => i == 3); // = -1 | т.к. индекс для данного числа не был найден. Вообще этого числа в массиве нет, прикинь?
            Array.Reverse(my_array); // "Переворачивает" массив, теперь начало это конец, а конец это начало (ауф);
            int[] my_array2 = my_array.Where(i => i > 5).ToArray(); // Получаем нужные числа, упаковываем в массив и задаем его в переменной;
            int my_array_first = my_array.Where(i => i > 5).First(); // Получаем первое попавшееся число больше 5;
            int[] my_array3 = new int[3];
            int my_array3_first = my_array3.Where(i => i > 5).FirstOrDefault(); // Если таких чисел нет, либо массив пустой, то функция возвращает стандартное значение для типа;
                                                                                // В нашем случае для типа "int" это число 0;

            // --Индексы и диапазоны--

            int[] new_array8 = { 4, 11, 87, 36, 90, 1 };
            Console.WriteLine(new_array8[new_array8.Last()]); // Получаем последний элемент из массива, т.е. цифру "1";

            /* Инфа для C# 8.0+
                В данном проекте ничего тут работать не будет, ибо .NET Framework. Именно поэтому это все закомменчено, ага;
                Обрати внимание, что для примера мы берем массив "new_array8" который был создан вот прям чуточку выше;
                Поднимаешь глаза и обалдеешь, когда его найдешь, вот настолько он близко;

                Console.WriteLine(new_array8[^1]); -> получаем последний элемент из массива, т.е. цифру "1";
                    Стоит отметить, что индексация с конца списка начинается с [^1] (единицы), а с начала списка начинается с [0] (нуля);
                    Именно поэтому используя символ "^" мы пишем "1" чтобы получить последний элемент;

                Console.WriteLine(new_array8[^2]); -> получаем предпоследний элемент из массива, т.е. цифру "90";

                Console.WriteLine(new_array8[0..4]); -> получаем значения с индексов [0], [1], [2], [3];
                    Индексация тут уже привычная, но с "изюминкой";
                    Чтобы получить значения с [0] до [3] мы должны написать "0..4", т.е. 4й индекс является "гранью"/"концом" и не попадает в список;

                Console.WriteLine(new_array8[..4]); -> получаем значения с индексов [0], [1], [2], [3] не указывая начало;
                    Т.е. мы получаем значения с самого начала списка, и до установленного значения;

                Console.WriteLine(new_array8[3..]); -> получаем значения с индексов [3], [4], [5] не указывая конец;
                    Т.е. мы получаем значения с установленного значения, и до конца списка;
            
                Console.WriteLine(new_array8[^2..]); -> получаем значения с индексов [4], [5] т.к. за начало мы берем второй индекс с конца;

                Console.WriteLine(new_array8[^4..^2]); -> получаем значения с индексов [2], [3], [4] т.к. за начало мы берем четвертый индекс с конца, а за конец второй индекс с конца;

                Console.WriteLine(new_array8[..^3]); -> получаем значения с индексов [0], [1], [2], [3] т.к. за конец мы берем третий индекс с конца;


                string str = "Hello, world"; -> тип "string" по факту тоже является массивом, ООП во всей своей красе, брух;
                Console.WriteLine(str[0]); -> таким образом мы можем получить первую букву "H" из нашей фразы "Hello, world";
                Console.WriteLine(str[^1]); -> а вот уже таким образом мы можем получить последнюю букву "d" из нашей фразы "Hello, world";
                    Всякие диапазоны по типу [0..4] тут работают точно так же, как и с обычными массивами (потому что "string" это тоже массив, лол);

            */


            // --Многомерные массивы--

            // --Двумерный прямоугольный массив--
            // тип_элементов_массива [,] имя_массива;

            int[,] two_dim_array; // -> наличие запятой "," между "[" и "]" обязательно, если необходимо создать именно двумерный массив;
            two_dim_array = new int[3, 5]; // -> создаем двумерный массив с условно треями строками и пятью колонками;
            two_dim_array[0, 3] = 1; // -> задаем значение "1" по координатам массива [0, 3];
            Console.WriteLine(two_dim_array[0, 3]); // считываем значение "1" по координатам массива [0, 3];

            int[,] two_dim_array2 = new int[3, 5]; // -> альтернативный метод создания двумерного массива, занимающий меньше кода;

            int[,] two_dim_array3 = new int[3, 5]
            {
                { 1, 2, 3, 4, 5 }, // 3 строки, по 5 элементов в каждой;
                { 6, 7, 8, 9, 10 }, // Если в первой строке уже находится 5 элементов, то в следующей также должно быть 5 элементов, т.к. это прямоугольный массив;
                { 11, 12, 13, 14, 15 }
            }; // Да, именно таким образом можно создавать двумерные массивы с заранее заданными значениями;

            int[,] two_dim_array4 = new int[,] // Можно не задавать размеры массива заранее, компилятор считает размер из вводных данных;
            {
                { 1, 2, 3, 4, 5 },
                { 6, 7, 8, 9, 10 },
                { 11, 12, 13, 14, 15 }
            };

            int[,] two_dim_array5 = // Да, и так тоже можно;
            {
                { 1, 2, 3, 4, 5 },
                { 6, 7, 8, 9, 10 },
                { 11, 12, 13, 14, 15 }
            };

            foreach (var item in two_dim_array5) // "foreach" создает переменную "item" для каждого элемента из массива "two_dim_array5";
            {
                Console.WriteLine(item); // Используем элемент как нам нужно либо же просто выводим в консоль;
            }

            int two_dim_array_length = two_dim_array.Length; // Узнаем, сколько элементов в массиве | 3 * 5 = 15;

            int two_dim_array_rank = two_dim_array.Rank; // Узнаем, сколько измерений в нашем массиве | 2;

            for (int i = 0; i < two_dim_array_rank; i++)
            {
                Console.WriteLine(two_dim_array.GetLength(i)); // Узнаем длину каждого измерения | 3 и 5;
            }

            int[,] two_dim_array6 = new int[4, 6];
            Random random = new Random(); // Создаем переменную класса "Random", т.к. без этого нельзя обратиться к нему для получения случайного числа;

            for (int i = 0; i < two_dim_array6.GetLength(0); i++) // Получаем длину первого измерения;
            {
                for (int j = 0; j < two_dim_array6.GetLength(1); j++) // Получаем длину второго измерения;
                {
                    two_dim_array6[i, j] = random.Next(100); // Генерируем для каждого элемента случайное значение с ограничением от 0 до 100;
                }
            }

            // --Ступенчатые (зубчатые) массивы--

            int[][] massives_inside_massives_wow = new int[5][]; // -> объявление двумерного зубчатого массива;
            // По факту работает как одномерные массивы внутри одномерного массива;
            // За счет этого у каждой "строки" основного массива могут быть самые разные размеры, в отличие от обычного двумерного массива [,];
            massives_inside_massives_wow[0] = new int[4]; // -> создаем новый массив размером в 4 внутри основного массива. Да, так просто;
            massives_inside_massives_wow[0][3] = 10; // -> задаем значение "10" индексу "3" внутри массива с индексом "0" который находится внутри основного массива. Ух, так и голову сломать можно;
            int[] massive_from_massive_with_massives_inside = massives_inside_massives_wow[0]; // -> получаем массив с индексом "0" из массива с массивами;

            for (int i = 0; i < massives_inside_massives_wow.Length; i++) // -> получаем длину основого массива, в нашем случае это "5";
            {
                for (int j = 0; j < massives_inside_massives_wow[i].Length; j++) // Получив индекс, обращаемся к каждому массиву внутри основного массива;
                {
                    Console.WriteLine(j); // Ну и наконец выводим число из массива внутри массива;
                }
            }

            // Трехмерные массивы работают по тем же принципам. Можно как создавать массивы внутри массивов, так и создать трехмерный массив через [,,];

            int sum = a_plus_b(5, 4); // Обращаемся к методу "a_plus_b", который складывает два числа "5" и "4", и получаем в итоге "9";

        }

        // ---Функции и методы---

        //      модификаторы тип_возвращаемого_значения название_метода(параметры)
        //      {
        //          тело метода
        //      }

        static int a_plus_b(int a, int b) // -> т.к. мы складываем две переменных типа "int", то в тип_возвращаемого_значения мы ставим "int";
        {
            return a + b; // Данный метод должен возвращать какие-то данные, именно для этого здесь нам нужен "return";
                          // Т.е. мы возвращаем данные туда, откуда эта функция была вызвана (см. строчку 498);
        }

        static void print_line() // "void" позволяет нашему методу не возвращать каких-либо значений, т.е. не использовать "return";
                                 // Мы также не запрашиваем никаких значений, т.к. для выполнения метода они не нужны;
        {
            Console.WriteLine("Активирован протокол самоуничтожения. Ваш компьютер взорвется через 3, 2, 1..."); // Мы просто выводим текст в консоль;
        }

        // --Перегрузка методов--


        /// <summary>
        /// Суммирует то, что можно суммировать.
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        // Небольшая фича. Если смотреть код через VisualStudio и навести на метод ниже, то можно увидеть описание, которые мы написали выше;
        static int please_sum(int a, int b) // Обычный метод с двумя переменными на входе;
        {                                   // Вызывается через "please_sum(число_1, число_2)";
            return a + b;
        }

        static int please_sum(int a, int b, int c) // Уже по факту является перегрузкой метода "please_sum";
        {                                          // Т.е. мы можем вызвать ту же функцию, но на входе будет три переменных;
            return a + b + c;                      // Вызывается через "please_sum(число_1, число_2, число_3)";
        }

        static double please_sum(double a, double b) // Также перегрузка метода "please_sum";
        {                                            // Здесь мы уже можем ввести две переменных уже не типа "int", а типа "double";
            return a + b;
        }

        static void cool_method()
        {
            int a = 0; // Переменные внутри "static" метода нельзя использовать из других методов;
        }

        int program_int = 0; // "Не-static" переменные внутри непосредственно "класса", в нашем случае класса "Program" (см. строчку 11, самое начало) также нельзя использовать внутри "static" методов;
        static int static_program_int = 5; // Данную переменную уже можно использовать внутри "static" методов;

        static void use_non_static_int_from_class()
        {
            static_program_int++;
            Program program = new Program(); // Однако же для использования "не-static" переменной мы может создать новый экземпляр нашего класса "Program";
            program.program_int++;           // И уже в этом экземпляре получать, менять значение и делать что вздумается. Это ООП, детка;
        }

        // --Области видимости--

        static void area_of_visibility1()
        {
            int var = 20;
        }

        static void area_of_visibility2()
        {
            //var = 30; -> мы не можем использовать переменную из другого метода. Нужно создавать свою переменную;
        }

        static int static_int = 4;
        static void area_of_visibility3()
        {
            int static_int = 10;
            Console.WriteLine(static_int); // В данном случае выведется число "10", т.к. мы задали внутри метода переменную "static_int";
                                           // Она же, в свою очередь, перекрывает переменную из класса "Program", внутри которого находится метод;
                                           // При этом, если не задавать переменную "static_int" и сделать её запрос, то будет взято число из класса "Program", т.е. "4";
        }


        // --Ссылочные (reference) и значимые (value) типы--
        // --Стек (stack) и управляемая куча (heap)--
        // Здесь будет очень много букафф, но тема важная. Если ниче не понятно, просто вернись к ней позже;

        static void method()
        {
            int a = 7; // Если навести на тип переменной, т.е. на "int", то можно увидеть, что этот тип является "структурой", или же "struct";
                       // Структуры размещается в "стеке", или же в "stack" - некоем объеме в оперативной памяти с высокой скоростью но небольшим размером для хранения значений в методах и пр.;
            System.Int32 b = 4; // Частичка ООП в глаз попала походу, не так ли? Да, "int" является попросту кратким псевдонимом класса "System.Int32" для более удобного использования;
            int c = a; // Не стоит пропускать эту строчку из вида, она нам понадобится. Просто запомни, что есть переменная "c", в которую мы скопировали данные из переменной "a";
            Random random = new Random(); // Тип "Random" уже является "классом", или же "class", и размещается уже в "управляемой куче", или же "heap";
            int[] array1 = new int[4]; // При наведении на "int" нам покажет "struct" и это может ввести тебя в заблуждение, ведь массивы на самом деле "классы", а не "структуры".;
            Array array2 = new int[4]; // Альтернатива созданию массива. Если навести на "Array", то можно увидеть, что это действительно "class";
            int key = (int)ConsoleKey.F12; // "ConsoleKey" является "enum" и также хранится в стеке, или же "stack";
            // Стек (stack) имеет маленький размер (1 мб), работает крайне шустро, и очищается сразу после выполнения метода;
            // Управляемая куча (heap) может иметь размер до 8 тб, все зависит от компа и архитектуры, и очищается только "Сборщиком мусора" (Garbage Collector);
            // Структуры, или же "struct" и энумерации, или же "enum", по факту унаследованы от "System.ValueType";
        }   // <- как только метод будет завершен, стек моментально очищается, т.к. те же переменные "a", "b", "c" и "key" больше нет смысла хранить;
            // Переменная "a" является отдельным объектом в памяти, как и "b", и "c". Почему "c"? Потому что мы попросту скопировали данные из переменной "a";
            // В этом и есть, собственно, смысл значимых типов "struct" и "enum". Метод закончился и выполнил свою работу, расходимся по домам, здесь не на что смотреть;
            // Хотя погоди-ка, а что с переменными "array1" и "array2"? Хороший вопрос, ведь эти переменные как раз таки ссылочного типа; Что это значит?
        static void check_my_back()
        {
            int[] array = new int[7]; // -> создавая массив, мы выделяем место в оперативной памяти, а конкретнее - управляемой куче;
                                      // Говоря проще, переменная "array" является лишь ссылкой на то место в оперативной памяти, в которой находится сам массив;
                                      // Именно поэтому мы используем "new" -> чтобы именно "создать" массив и выделить под него место в оперативной памяти;
                                      // А через "int[] array" мы просто создаем ссылку, которую можем потом использовать, и говорим, объекты какого типа ссылка может хранить;
                                      // Именно поэтому данный тип и называется "ссылочным". И сам объект, на который ведет ссылка, может храниться в памяти достаточно долго;
                                      // Однако кое-что в этом примере хранится и на "стеке", а конкретнее - ссылка, т.е. переменная "array", и будет храниться там до тех пор, пока не будет выполнен метод;

            int[] second_array = array; // -> в данном случае мы попросту создали вторую ссылку на уже созданный массив, т.е. память в куче выделяться не будет, ибо объект уже существует;
        }

        static void pubg_or_playstation5()
        {
            int a = 5; // -> мы условно создаем "объект" с именем "a", значение которого является "5";
            return_incremented(a); // -> здесь при помощи функции мы пытаемся увеличить значение переменной "a" на +1 (см. ниже);
            Console.WriteLine(a); // = 5 | Почему так? Смотри ниже;
            int[] array = new int[3];
            set_value_in_array(array);
            Console.WriteLine(array[0]); // = 1 | Почему так? Да ниже ты уже посмотри, господи...
        }

        static void return_incremented(int a) // Не смотря на то, что имя у этой переменной то же, что и выше, это уже совершенно иной "объект";
        {
            a++; // Как только переменная покинет контекст данного метода, ее значение будет удалено из памяти;
        } // И по возвращению обратно, никакого увеличения числа не будет. Мы просто создали новый объект, увеличили его значение на +1, и на этом больше ничего;

        static void set_value_in_array(int[] array) // Здесь мы передаем ссылку на существующий в управляемой куче объект;
        {
            array[0] = 1; // Мы задаем индексу [0] значение "1";
        }                 // Имея правильную (или моднее сказать валидную?) ссылку на нужный объект мы можем получить данные из любого места, в т.ч. вернувшись обратно;


        // --null--
        // Че это ваще такое;

        static void help_me()
        {
            bool b; // = false | Значение "false" является стандартным при объявлении переменной типа "bool";
            int a; // = 0 | Так же, как и значение "0" является стандартным для переменных типов "int", "double" и т.д.;
            double d; // = 0 | Догадываешься почему? Да. Именно потому, что это структуры, т.е. типы значимого типа - они не могут быть "null", они должны хранить какое-то значение;
            Random random; // = null | А вот это уже класс. И если у него нет какого-либо значения по умолчанию, то нам выдаст "null";
            int[] array; // = null | Почему? Потому что отсутствует ссылка на существующий объект. Это как создать ярлык на рабочем столе, не указав путь к программе;
            Program program; // = null | И это ярлык, к слову, таки занимает место в стеке. Нам же нужно потом как-то обращаться к этому ярлыку, верно?
            string str; // = null | Интересно, не так ли? Да, тип "string" является классом и может иметь значение "null";

            int[] int_array = new int[3]; // Создадим для еще одного примера массив и выделим ему место в памяти;
            int_array = null; // <- здесь мы, грубо говоря, удаляем из "ярлыка" ссылку/путь к реальному массиву в управляемой куче;
            //Console.WriteLine(int_array[0]); <- если бы мы сейчас попытались вытащить данные из массива, то получили бы ошибку, т.к. у ярлыка больше нет пути к массиву;
        }

        // --Оператор объединения с null--
        // ??;

        static void best_method()
        {
            string str = "Hello, world!";
            Console.WriteLine(str);
            str = null;
            string result;
            if (str == null)
            {
                result = "Ошибка - нет данных!";
            }
            else
            {
                result = str;
            } // Данный код не эффективен, ведь это все можно уместить в одну строчку;

            Console.WriteLine(str ?? "Ошибка - нет данных!"); // Используя оператор "??" мы сокращаем пример выше до минимальных размеров;
            result = str ?? ""; // Или же:
            result = str ?? string.Empty; // Тот же самый эффект, что и с "";
            Console.WriteLine("Количество символов = {0}", result.Length);


            // --Оператор присваивания объединения с null--
            // ??=;
            // Внимание! Работает только на C# 8.0+

            // str ??= string.Empty; -> в таком случае для примера выше нам можно не создавать переменную "result". Мы просто превращаем значение с "null" в значение string.Empty, или же "" (пустота, ничего);
            // Console.WriteLine("Количество символов = " + str.Length) | = 0, т.к. "" (пустота, тьма, ничего, космос);

            // int[] array = null;
            // array ??= new int[0]; -> так же работает и с массивами, чтобы не напороться на ошибку. Если ссылки на действительный массив нет, то мы создаем новый и обращаемся следующей строке к нему;
            // Console.WriteLine("Количество элементов в массиве = " + array.Length);


            // --Оператор условного null--
            // ?.;

            int[] array = null;
            Console.WriteLine("Сумма элементов массива = {0}", array?.Sum()); // Для того, чтобы у нас вдруг не появилось исключения, мы исползуем оператор ?.;
                                                                              // Т.е. прежде чем мы обратимся к массиву, на который ведет переменная "array", работающая как ссылка, чтобы выполнить функцию "Sum()";
                                                                              // С этим оператором мы проверяем, действительна ли данная "ссылка", и если же нет, то функция "Sum()" выполняться не будет, таким образом мы избегаем исключения;
                                                                              // Однако из-за того, что ничего не выполняется, нам выведет просто "Сумма элементов массива = ";
            Console.WriteLine("Сумма элементов массива = {0}", array?.Sum() ?? 0); // -> таким образом мы выводим "Сумма элементов массива = 0" если ссылка на массив недействительна;
        }


        // --Ключевое слово "ref"--
        // Передача аргументов по ссылке;

        static void main_method()
        {
            int a = 2;
            not_ref_method(a); // a = 2;
                               // Как мы уже знаем, мы не можем так просто изменять структуры из другого метода, т.к. мы просто создаем новую структуру и копируем в нее значение;
                               // Не смотря на то, что в методе мы присвоили переменной "a" значение "-3", не смотря на одинаковое имя это две разных переменных;
                               // Именно поэтому по возвращению обратно мы не увидим изменений;
            ref_method(ref a); // a = -5;
                               // Однако благодаря ключевому слову "ref" мы можем создать ссылку на место нашей переменной в оперативной памяти;
                               // И тогда все изменения внутри вызванного метода отразятся и по возвращению обратно;
                               // В таком случае нам необходимо иметь слово "ref" как на вызове метода...
        }

        static void not_ref_method(int a)
        {
            a = -3;
        }


        static void ref_method(ref int a) // Так и на приеме;
        {
            a = -5;
        } // Конечно, в таком виде данная фича бесполезна, но этот пример просто более нагляднее, чтобы показать суть ключевого слова "ref";

        struct my_struct
        {
            public int a;
            public float b;
            public double c;
        }

        static void juicy_method()
        {
            my_struct new_struct = new my_struct();
            set_my_new_struct_pls(ref new_struct); // Более правильный пример использования подобной фичи;
        }

        static void set_my_new_struct_pls(ref my_struct _struct)
        {
            _struct.a = 4;
            _struct.b = 7.0f; // -> благодаря "f" мы даем понять компилятору, что это именно тип "float";
            _struct.c = 3.2d; // -> ну а здесь то же самое, только тип "double";
        }

        static void another_cool_method() // Еще один интересный момент с ключевым словом "ref", который будет тебе явно интересен;
        {                                 // И касается он уже не структур, а классов;
            int[] array = { 1, 6, 3, 2 }; // Массивы ведь являются классами, верно? Что будет, если мы используем ключевое слово "ref" с ним?
            why_are_we_still_here(array); // array = {1, 6, 3, 2} | Здесь мы скопировали ссылку в метод, а в самом методе задали переменной значение "null";
                                          // Однако по возвращении наша ссылка все еще осталась нетронутой, она все еще ведет туда, куда и вела;
            just_to_suffer(ref array); // array = null | Здесь мы как бы создали "ссылку" на "ссылку", грубо говоря;
                                       // Именно поэтому, задав переменной значение "null", по возвращении здесь наша переменная "array" уже тоже является "null";
            i_can_feel_my_leg(ref array); // array = int[10] | С этой штукой все должно встать на свои места для тебя. Смотри;
                                          // Мы создали новую "ссылку" на нашу "ссылку" под именем "array", которая вела куда-то в управляемую кучу, где хранился массив;
                                          // И в методе мы задали нашей "ссылке" путь к новому массиву размером в 10, который там же в методе и создали;

            // --Ссылочные локальные переменные--;

            int b = array[0]; // Создаем переменную "b" и присваеваем ей значение из индекса "0" массива "array";
            b = -5; // <- мы просто создали новую переменную и изменили ее значение, на массив это никак не повлияло;

            ref int c = ref array[0]; // Однако создав ссылочную локальную переменную и привязав её к индексу массива...
            c = -5; // Задавая значение ей мы уже будет работать напрямую с массивом, т.е. здесь мы присвоили индексу "0" значение "-5";

            ref int d = ref and_my_arm(array); // Также если наш метод возвращает ссылочную переменную...
            d = 10; // То мы также сможем взаимодействовать с самим массивом;
        }

        static void why_are_we_still_here(int[] array) // Мы получаем ссылку на массив, а не сам массив;
        {                   
            array = null; // Скопировав ссылку, данный метод удаляет свою ссылку, не трогая ту, с которой она была скопирована;
        }                 

        static void just_to_suffer(ref int[] array) // Обрати внимание на ключевое слово "ref" - оно указывает, что нам должна прийти именно "ссылка" на "ссылку"
        {
            array = null; // И, соответственно, имея "ссылку" на "ссылку", мы задаём той "ссылке" значение "null";
        }

        static void i_can_feel_my_leg(ref int[] array)
        {
            array = new int[10]; // А здесь мы создаем новый массив и копируем путь к нему нашей ссылке;
        }

        static ref int and_my_arm(int[] arr) // Данный метод возвращает не просто переменную, но ссылочную переменную из-за ключевого слова "ref" перед "int";
        {
            return ref arr[1]; // Вернув ссылочную переменную, тот метод, из которого был вызван данный метод, сможет использовать лишь одну переменную для взаимодействия с конкретным индексом массива;
        }


        // --Ключевое слово "out"--
        // --Разница между "ref" и "out"--
        // По факту, "out" делает практически все то же, что и "ref", разница лишь в деталях;

        static void even_my_fingers()
        {
            int a;
            // the_body_ive_lost(ref a); <- мы не можем использовать в методе, где на входе должен быть "ref", переменную у которой нет значения;
            the_comrades_ive_lost(out a); // <- а вот в методе, где на входе должен быть "out" как раз можем;
            the_body_ive_lost(ref a); // <- и после использования метода выше, т.к. переменной "a" из-за "out" обязательно должно быть выдано значение, мы можем использовать её с "ref";
        }

        static void the_comrades_ive_lost(out int value) // В методе с "out" на входе мы обязаны задать значение переменной;
        {
            value = 5; // Без этого компилятор будет сильно ругаться и выдаст ошибку;
        }

        static void the_body_ive_lost(ref int value) // При этом, в методе с "ref" на входе мы не обязаны делать с переменной что-либо, у нас просто есть такая возможность и все;
        {                                            // Но нам обязательно нужно иметь правильную ссылку на переменную с каким-либо значением, а не "null";
        }

        static void press_f_to_pay_respect()
        {
            string str = Console.ReadLine();
            int.TryParse(str, out int result); // -> интересный момент. Если добавить сюда "out", то в случае неудачной попытки парсинга благодаря этому ключевому слову...
            Console.WriteLine(result); // Нам будет выведено число "0", т.е. стандартное значение для переменной типа "int", т.к. "out" ОБЯЗАН присвоить переменной значение;
        }


        // --Ключевое слово "in"--

        static void sus_method()
        {
            int a = 7; // Создаем переменную;
            another_sus_method(a); // Отправляем её в метод, добавлять ключевое слово "in" при этом не нужно;
        }

        static void another_sus_method(in int value) // Обращаем внимание на ключевое слово "in" на вводе;
        {
            Console.WriteLine(value); // <- Мы можем считывать переменную "value";
            // value = 3; <- Но не можем никак её изменить, иначе компилятор выдаст нам ошибку;
            // В чем смысл использования ключевого слова "in"?
            // (Примечание - создавать ссылки имеет смысл только для структур и энумераций. Переменные, в которых "хранятся" классы и так уже являются ссылками);
            // В том, что мы с его помощью создаем ссылку на то место в оперативной памяти, в которой находится значение реальной переменной;
            // Именно поэтому благодаря "ref" и "out" мы могли менять значение переменной "извне", т.к. имели на нее прямую ссылку;
            // Обычно при вводе переменной в метод значение попросту копируется и создаётся новая переменная, и для нее выделяется новое место в оперативной памяти;
            // А так, если значение переменной занимает очень много места в памяти (например, вам необходимо изменить четыре переменных типа "double" по 8 байт каждая)...
            // Мы можем создать ссылку на это место, сэкономив место в памяти и при этом гарантируя, что реальное значение изменено не будет;
            // Особенно это касается тех случаев, когда мы создаем свои структуры, и в них находится очень много данных;
            // Тогда при использовании ссылочных переменных мы не только выигрываем в памяти, но и в производительности;
        }


        // --Ключевое слово "params"--

        static void rofl_method()
        {
            int a = pls_sum(3, 5); // <- вызываем обычный метод сложения двух чисел;
            int b = pls_sum(a, 10, 7); // <- вызываем перегруженный метод сложения уже трех чисел;
            // Согласись, что создавать отдельную перегрузку для метода будет довольно накладно, если мы вдруг захотим сложить не три числа, а пять, десять или двадцать;
            int c = sum_pls(10, 15, a, 38, 40, 19, b, 34, 20, 49); // <- вызываем уже другой метод, в котором на входе стоит ключевое слово "params";
            here_we_go_again("Hello, world!", 10, '%', 2.4f, false); // <- отправляем в еще один метод значения самых разных типов, таких как "int", "string", "char" и т.д.;
                                                                     // Чтобы понять что это вообще такое, посмотри в код этого метода;
        }

        static int pls_sum(int a, int b) // Обычный метод;
        {
            return a + b;
        }

        static int pls_sum(int a, int b, int c) // Перегрузка предыдущего метода;
        {
            return a + b + c;
        }

        static int sum_pls(params int[] parameters) // Благодаря "params" мы можем иметь на входе столько чисел, сколько нам потребуется без лишних перегрузок;
        {                                           // Обрати внимание, что на входе мы также имеем массив "int[] parameters";
            int result = 0;     // По факту, из-за "params" нам не придется перед вызовом этого метода создавать новый массив через "new int[]" и запихивать туда переменные;
            for (int i = 0; i < parameters.Length; i++) // Мы просто пишем числа или пишем переменные через запятую -> (1, 2, 3, 4, 5);
            {
                result += parameters[i]; // Ну и здесь собственно складываем поочередно с каждым значением из массива;
            }
            return result;
        }

        static void here_we_go_again(params object[] parameters) // Мы определяем тип данных в массиве как "object", т.е. общий, "родительский" тип для вообще всех типов;
        {           // Именно благодаря этому при вызове данного метода мы можем вводить значения вообще любых типов от "int" до "string", и массив их будет спокойно хранить;
            string message = "Тип данных {0], значение {1}";
            foreach (var item in parameters) // Здесь "var" говорит компилятору, что мы не знаем какие конкретные типы здесь будут, и он должен определять их сам;
            {
                Console.WriteLine(message, item.GetType(), item); // Ну и, собственно, вывод в консоль сообщения, типа и значения каждой переменной в массиве;
            }
        }


        // --Необязательные параметры методов--

        static void i_have_no_ideas_how_to_name_this_method()
        {
            int a = sum_again(3, 5); // <- вызываем метод, складываем чиселки и получаем результат;
            int b = sum_again(4, 10, true); // <- вызываем метод, складываем чиселки, выводим результат в консоль и получаем обратно;
        }

        static int sum_again(int a, int b, bool enableLogging = false) // Можно задать значения параметров метода, если их наличие при вызове метода необязательно;
        {           // Т.е. можно как написать "sum_again(3, 5)", и тогда вывода в консоль не будет, так и "sum_again(4, 10, true)", если мы хотим вывести результат в консоль;
            int result = a + b;
            if (enableLogging) Console.WriteLine("{0} + {1} = {2}", a, b, result); // <- к слову, можно писать "if" и без фигурных скобок, но тогда нужен ";" в конце;
            return result;
        }


        // --Именованные параметры методов--

        static void ok_boomer()
        {
            int a = sum_again(b: 3, a: 5); // <- да, мы можем передавать значения методу и в обратном порядке, главное использовать имена;
            int b = and_sum_again(value2: 9, value1: 4); // <- еще один наглядный пример c использованием метода ниже, где переменные называются "value1" и "value2";
        }

        static int and_sum_again(int value1, int value2)
        {
            return value1 + value2;
        }


        // --Рекурсия--
        // --Методы и стек--
        // --Переполнение стека (stack overflow)--

        static void hello_choomba()
        {
            Console.WriteLine("Hello, choomba!");
            hello_choomba(); // <- вызов метода внутри себя же и называется рекурсией. По факту, некий аналог бесконечного цикла, только в виде метода;
                             // Т.е. это практически то же самое, что и использование "while(true)";
            // Однако в случае с использованием "while(true)" нам абсолютно по барабану на стек, его размер и переполнение;
            // Рекурсия же ограничена максимальным размером стека, т.к. каждый вызов метода заполняет его память;
            // Рано или поздно, если рекурсия бесконечная, то память кончится и нам выдаст ошибку "StackOverflow";
            // Отследить "стек вызовов" это можно запустив отладку в VS, и посмотрев вниз;
            // Почему кончается память? Потому что стек хранит данные, из какого метода был вызван данный метод, чтобы вернуться и продолжить выполнение;
            // А т.к. мы вызываем себя же внутри себя, и стек хранит инфу о том, куда нужно вернуться, "call stack" начинает заполняться огромным количеством вызовов;
            // Рекурсия ОБЯЗАНА иметь условия для выхода, если ты не хочешь, чтобы программа схлопнулась;
        }

        static void bye_choomba(int i = 0)
        {
            Console.WriteLine(i);
            if (i >= 3) return; // <- более удачный пример использования рекурсии, т.к. мы имеем условие для выхода;
            i++;                // Но лучше так, конечно, не делать. Есть более удачные примеры использования рекурсии, но на это нужно слишком много кода;
            bye_choomba(i);
        }


        // --Преобразование и приведение примитивных типов--

        static void xbox_five()
        {
            byte o = 5;
            int a = 4;
            double b = 3.29;
            float c = a; // <- нам необязательно конвертировать "int" во "float" вручную. Это называется "неявным" (или же "implicit") преобразованием, т.е. автоматическое;
            playstation_ten(a); // <- мы даже можем запихнуть "int" в метод, где на входе должен быть "float";
            a = o;
            c = (float)b; // <- здесь же мы не можем так просто преобразовать "double" во "float"
                           // Именно поэтому нам необходимо использовать "неявное" (или же "explicit") преобразование, т.е. ручное;
                           // Так что указываем перед переменной в скобках (float) тип, в который нам нужно преобразовать значение типа "double";
            // Почему так происходит и в чем дело?
            // Нам просто-напросто не дают по своей глупости (а мы, программисты, иногда очень сильно тупим) внезапно потерять кучу данных из-за ошибки в коде; 
            int var1 = 10;
            float var2 = var1; // <- "float" может хранить бОльший диапазон значений, чем "int", так что мы используем расширяющее преобразование;
            double var3 = var2; // <- а "double", в свою очередь, может хранить бОльший диапазон, чем "float";
            // И если мы пойдем в обратном порядке...
            var2 = (float)var3; // <- то нам нужно дать компилятору понять, что нам действительно нужно "обрезать", или же сузить диапазон до допустимых для типа "float" значений;
            var1 = (int)var2; // <- и так же, как и в предыдущем случае мы вручную "обрезаем" диапазон с "float" до "int";
            playstation_ten((float)var3); // <- ну и, т.к. на входе метода нам нужен "float", а у нас "double", то мы используем явное преобразование;

            int v = 3;
            bool boolean = Convert.ToBoolean(v); // <- в булевую так просто не преобразовать, поэтому мы используем "Convert.ToBoolean()" в данном случае;

            double bb = 2.4; // <- мы можем просто ввести "2.4", если заданный тип это "double";
            float f = 2.4f; // <- однако в случае с типом "float" мы уже не сможем так сделать, т.к. компилятор думает что мы вводим "double";
                            // Поэтому после значения "2.4" нам необходимо поставить "f", т.е. "float", чтобы уточнить, что мы вводим именно "float" значение;
            int k = v + (int)f; // <- если мы хотим получить значение типа "int", то в данном случае нам нужно преобразовать "float" в "int";
            string s = "5";
            int j = int.Parse(s); // <- в случае, если нам необходимо преобразовать "int" в "string", то мы не сможем просто использовать "(int)";
            int u = Convert.ToInt32(s); // <- еще один вариант преобразования "string" в "int";
        }

        static void playstation_ten(float value)
        {
            Console.WriteLine(value);
        }


        // --Арифметическое переполнение--

        static void cheeseburger()
        {
            // --Целые числа--

            byte a = 1;
            byte b = 2;
            byte c = (byte)(b - a); // = 1 | Почему здесь мы используем (byte)?
                                    // Потому что оператор "-" (минус) выполняется с двумя значениями типа "int" и выводит "int" соответственно;
                                    // Т.е. в данный момент оператор "-" преобразует два значения типа "byte" в "int" и выводит "int", который мы преобразуем обратно в "byte";
            byte d = (byte)(a - b); // = 255 | Почему так? Ведь мы же просто совершили операцию "1 - 2"...
                                    // Диапазон значений типа "byte" 0 - 255;
                                    // Т.к. мы не можем задать значение "-1" типу "byte", то происходит "переполнение" и мы получаем вместо значения "0" значение "255";

            int e = int.MaxValue;   // = 2147483647 | -> берем максимальное значение типа "int"...
            e++;                    // = -2147483648 | -> добавляем +1 и оп, мы уже на нижней границе;

            int f = int.MinValue;   // = -2147483648 | -> берем минимальное значение типа "int"...
            f--;                    // = 2147483647 | -> добавляем -1 и оп, мы уже на верхней границе;

            e = checked(e - 1);     // -> с помощью ключевого слова "checked" в случае переполнения нам выдаст исключение (или попросту ошибку "Overflow");
            checked                 // -> еще один метод использования ключевого слова "checked";
            {
                f++;                
            }
            try
            {
                f = checked(f - 1);
            }
            catch (OverflowException)
            {
                Console.WriteLine("Ошибка переполнения!");
            }

            // --Дробные числа--
            // А у них тут есть некоторые нюансы, в отличие от целых чисел;

            double q = 1.0 / 0.0; // Кто сказал что на ноль делить нельзя?
            Console.WriteLine(double.IsInfinity(q)); // = true | У нас не возникает переполнения, число просто становится "infinity", т.е. бесконечным;

            double w = 0.0 / 0.0; // Кто сказал что еще и ноль на ноль делить нельзя, а?
            Console.WriteLine(double.IsNaN(w)); // = true | "NaN", или же "Not a Number", указывает нам на то, что данное значение не является числом;

            double t = double.MaxValue + double.MaxValue; // <- берем два максимальных значения типа "double" и...
            Console.WriteLine(double.IsInfinity(t)); // = true | Также не возникает переполнение, число просто становится бесконечным;

            // С типом "float" все работает так же, как и с "double";


            decimal d1 = decimal.MaxValue;
            decimal d2 = decimal.MaxValue;
            decimal d3 = d1 + d2; // Тип "decimal" при переполнении в ЛЮБОМ случае выдаст исключение, хоть тресни;
        }

        // --Null-совместимые значимые типы (Nullable)--
        // System.Nullable

        static void san_andreas()
        {
            string str = null; // <- мы спокойно можем задать переменной "str" значение "null", т.к. она имеет тип "string", который является "ссылочным";
            // int a = null; <- в данном случае такой прикол уже не прокатит, т.к. тип "int" является "значимым".
            DateTime? dateTime = null; // <- тип "DateTime" также является "значимым", однако в данном случае из-за знака "?" мы все же смогли присвоить переменной значение "null";
            int? a = null; // <- обрати внимание, что знак "?" стоит именно после типа "int", т.к. благодаря этому мы превращаем тип из "значимого" в "Nullable";
            Console.WriteLine(a.HasValue); // = false | у "Nullable" типов появляются два дополнительных поля "HasValue" и "Value";
            if(a.HasValue) // <- Собственно, если значение равно "null", то "HasValue" будет выдавать "false";
            {
                Console.WriteLine(a.Value); // <- С помощью "Value" мы можем получить реальное значение переменной;
            }
            // Некоторые примеры, которые лучше помогут понять, что вообще здесь происходит;

            Console.WriteLine(a = null); // = true | Ради того, чтобы понимать, что в переменной ДЕЙСТВИТЕЛЬНО нет никакого значения, мы и превращаем её в "Nullable"
            Console.WriteLine(a.HasValue); // = false;
            Console.WriteLine(a.GetValueOrDefault()); // = 0;
            Console.WriteLine(a.GetValueOrDefault(3)); // = 3;
            Console.WriteLine(a ?? 55); // = 55;
            //Console.WriteLine(a.Value); <- В случае, если мы попытаемся получить реальное значение, когда "a == null", то нам выдаст исключение;

            a = 2; // <- задаем переменной значение "2";
            Console.WriteLine(a = null); // = false;
            Console.WriteLine(a.HasValue); // = true;
            Console.WriteLine(a.GetValueOrDefault()); // = 2;
            Console.WriteLine(a.GetValueOrDefault(3)); // = 2;
            Console.WriteLine(a ?? 55); // = 2;
            Console.WriteLine(a.Value); // = 2;

            int b = 5; // Обычный тип "int", не-Nullable;
            int? c = 10; // Тип "Nullable", в который завернут тип "int";
            int? result = b + c; // Для значения результата у нас тоже тип "Nullable";
            Console.WriteLine(result); // = 15;
            Console.WriteLine(b == c); // = false;
            Console.WriteLine(b > c); // = false;
            Console.WriteLine(b < c); // = true | В целом, мы видим типичное поведение для типа "int";

            c = null; // Но что будет, если одну из переменных мы превратим в "null"?
            Console.WriteLine(result); // =  | т.е. ничего, пустое поле;
            Console.WriteLine(b == c); // = false | т.к. "5 != null";
            Console.WriteLine(b > c); // = false | т.к. операции сравнения с "null" всегда выдают "false";
            Console.WriteLine(b < c); // = false | та же ситация;
        }


        // --Ключевое слово "var"--
        // --Неявно типизированные локальные переменные--

        static void jackie()
        {
            var t = 5; // <- это тип "int", или же "System.Int32";
                       // Такого типа данных, как "var", НЕ СУЩЕСТВУЕТ;
                       // Это просто ключевое слово, которое указывает компилятору, что тот должен выяснить тип переменной самостоятельно в зависимости от значения;
            var s = "Hello, world!"; // <- компилятор определяет здесь тип переменной как "string", или же "System.String";
            var m = new float[10]; // <- компилятор определяет здесь тип переменной как "float[]", или же "System.Single[]";
            Console.WriteLine(t.GetType()); // <- метод "GetType()" есть у всех типов данных, т.к. он есть у типа "System.Object", который является базовым типом для всех типов;
                                            // Благодаря этому мы можем получить тип любого типа данных;
            // t = "Hello, world!"; <- если же мы попытаемся в переменную "t", где мы использовали ключевое слово "var", вставь значение другого типа, компилятор выдаст ошибку;
            // C# все еще остается строго типизированным языком, и что попало в эту переменную не сунешь, даже если очень хочется;
            // Если мы создали переменную, ввели ключевое слово "var", и задали ей значение типа "int", то переменная не стала типом "var", т.к. такого типа не существует...
            // Она взяла тип из значения и присвоила его себе;
            t = 10; // <- как видишь, значение типа "int" сюда спокойно встает;
            int a = 4;
            int i = t + a; // <- как видишь, мы даже можем проводить математические операции между этими двумя переменными, т.к. они оба, по факту, являются типом "int";
            // var p = null; <- присвоить значение "null" при использовании ключевого слова "var" не выйдет, т.к. компилятор выдаст ошибку;
            // Он попросту не может понять, какой тип данных вследствие этого ему нужно присвоить переменной;
            var p = "text"; // <- однако когда тип данных уже был инициализирован, и переменная получила тот же тип "string", который является ссылочным...
            p = null; // <- то мы уже можем задать переменной значение "null", т.е. "отсутствие ссылки";

            Dictionary<int, string> k = new Dictionary<int, string>(); // <- вместо того, чтобы полностью писать тип, особенно когда он занимает много места...
            var d = new Dictionary<int, string>(); // <- можно просто воспользоваться ключевым словом "var";
            var j = new List<int>();
            var h = new { Name = "Георгий", Age = 28 }; // <- ключевое слово "var" просто незаменимо при использовании анонимных типов данных;
                                                        // Компилятор условно "сам" задает необходимый для обработки такой переменной тип;

            int[] numbers = { 1, 3, 7, 2, 4, 10, 8 };
            var result = from u in numbers where u > 5 select u; // <- пример использования ключевого слова "var" вместе с LINQ;
        }


        // --enum (перечисления)--

        enum DayOfWeek
        {
            Sunday, // = 0 | <- базовым типом данных для "enum" является "int";
            Monday, // = 1;
            Tuesday = 3, // = 3 | <- можно самому задавать значение...
            Wednesday, // = 4 | <- и если не задавать следующее, то оно автоматические станет +1;
            Thursday, // = 5;
            Friday = 7, // = 7;
            Saturday // = 8;
        }

        static void no_problems()
        {
            Console.WriteLine(DayOfWeek.Monday); // = Monday | <- нам покажет "идентификатор";
            Console.WriteLine((int)DayOfWeek.Wednesday); // = 3 | <- нам покажет реальное значение, т.к. мы приводим его к "int";
            Console.WriteLine((int)DayOfWeek.Saturday); // = 8;
            Console.WriteLine(Enum.GetUnderlyingType(typeof(DayOfWeek))); // = System.Int32 | <- при помощи "Enum.GetUnderlyingType()" получаем тип данных нашего "enum";
            Console.WriteLine((DayOfWeek)3); // = Tuesday | <- приводим значение типа "int" к нашему "enum", и т.к. в "DayOfWeek" "Tuesday = 3", то нам показывает именно его;

            DayOfWeek dayOfWeek;
            int value = 55;
            dayOfWeek = (DayOfWeek)value; // = 55 | т.к. в нашем "enum" нет такого значения, то приведение не осуществляется;
            // Эту проблему можно решить следующим путем:
            if(Enum.IsDefined(typeof(DayOfWeek), value)) // <- при помощи "Enum.IsDefined()", есть ли в нашем "enum" элемент с кодом 55 (а его, кстати, нет);
            {
                dayOfWeek = (DayOfWeek)value; // <- присваиваем значение, если такой код есть;
            } 
            else
            {
                throw new Exception("Invalid DayOfWeek value"); // <- выкидываем исключение и закрываем программу, если что-то пошло не так;
            }

            var values = Enum.GetValues(typeof(DayOfWeek)); // = [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]

            string str = Console.ReadLine(); // <- можем ввести какой-нибудь день недели
            DayOfWeek day = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), str, ignoreCase: true); // <- парсинг текста в переменную типа "DayOfWeek";

        }

        enum DayOfWeek2: byte // <- можем задать тип данных для "enum", чтобы экономить место в оперативной памяти;
        {
            Sunday, // = 0;
            Monday, // = 1;
            Tuesday, // = 2;
            Wednesday, // = 3;
            Thursday, // = 4;
            Friday, // = 5;
            Saturday // = 6;
        }
    }


    // --ООП--
    // --Класс--
    // --Объект класса--
    // --Модификаторы доступа--
    // --Конструктор класса--
    // --Ключевое слово "this"--
    // --Свойства "get" и "set"--

    class Point // <- создаем новый класс, который будет являться неким "шаблоном" для хранения информации о точке в двумерном пространстве;
    {
        public int x; // = 0;
        public int y; // = 0;
        private int point_id; // = 0 | мы можем использовать данную переменную ТОЛЬКО внутри класса;
        public void show_coordinates()
        {
            Console.WriteLine($"X: {x} | Y: {y}"); // <- покажет "x" и "y", если мы вызываем данный метод извне;
        }
        public int[] return_coordinates()
        {
            return new int[] { x, y }; // <- возвращает массив размером в 2, в котором находятся значения переменных "x" и "y";
        }
        private int clamp_point_id()
        {
            if (point_id > 0) return point_id; else return 0; // <- можем создавать какие-либо условия вывода переменной "point_id";
        }
        public void set_point_id(int id)
        {
            point_id = id; // <- т.к. переменная "point_id" недоступна извне, но нам необходимо ее назначить, то мы можем создать для этого метод;
        }
        public int get_point_id()
        {
            return clamp_point_id(); // <- мы можем изнутри вызвать приватный метод нашего класса, это также вроде как называют еще "инкапсуляцией";
        }
        int color_id; // = 0 | Если мы не указываем модификатор доступа, то переменная становится "private", но обычно модификатор все же указывают;
        public int ColorID // <- теперь при модификации переменной "ColorID", мы можем менять "color_id" с условиями, которые нам необходимы;
        {
            get
            { return color_id; }
            set
            {
                if(color_id != value && color_id >= 0) { color_id = value; } // <- "value" это входное значение;
            }
        }
        string point_name;
        public string PointName
        {
            get { return point_name; }
            private set { point_name = value; } // <- таким образом мы сможем получить значение "point_name" извне, но задать сможем только внутри класса;
        }
        public int point_size { get; set; } // <- для того, чтобы не писать всю эту большую писанину выше...
        // Когда нам не нужна какая-то логика при получении и выдаче значений, мы можем воспользоваться данным сокращением;
        // Такая штука сама создает приватную переменную, когда мы не хотим нарушать инкапсуляцию;
        public int point_size2 { get; } // <- можно оставить только "getter";
        public int point_size3 { get; private set; } // <- можно также назначить "setter" приватным;
        public Point() // <- конструктор класса, который вызывается при создании нового экземпляра данного класса, т.е. "Point point = new Point()";
        {
            x = 0; y = 0;
        }
        public Point(int x, int y)
        {
            this.x = x; this.y = y; // <- ключевое слово "this" здесь необходимо, чтобы устранить "неоднозначность" переменных;
            // Таким образом мы пишем в коде, обращаясь к нашему экземпляру класса, что нам...
            // нужна переменная с именем "x" именно из нашего класса, а не входных параметров;
        }
        public Point(int x, int y, int _point_id, int _color_id) : this(x, y) // <- использование "перегрузки" конструктора класса...
        {   // А также при помощи ключевого слова "this" мы используем "оригинальный" конструктор класса...
            //this.x = x; this.y = y; <- чтобы тупо не дублировать код, который уже существует;
            point_id = _point_id; // <- как видишь, использования ключевого слова "this" не обязательно, если имена переменной и входного параметра разные;
            color_id = _color_id;
        }
    }

    class MyClass
    {
        static void Main()
        {
            Point p = new Point(); // <- создаем новый объект класса, создается таким же образом, как мы создавали массив int[];
            p.x = 4; p.y = 2; // <- задаем значения внутри объекта класса;
            Console.WriteLine($"X: {p.x} | Y: {p.y}"); // <- считываем эти значения;
            Point p2 = new Point();
            p2.x = 8; p2.y = 3; // <- новый объект, новые данные, совершенно другое место в оперативной памяти и никаких пересечений с прошлым объектом "p" класса "Point";

            p2 = null;
            // p2.x = 5; p2.y = 6; <- если мы попытаемся задать значения в переменной, в которой отсутствует ссылка на объект, то нам выдаст исключение;
            p.show_coordinates(); // <- можем создать внутри класса метод, чтобы позднее вызывать его по мере необходимости;
                                  // Так мы вызываем метод "show_coordinates", который показывает значения переменных "x" и "y" актуальные для данного экземпляра объекта;
            int[] new_array = p.return_coordinates(); // <- создаем переменную типа "int[]" и возвращаем из метода значения "x" и "y" в виде массива "int[]";
            // int p_id = p.point_id; <- нам не дадут этого сделать, т.к. переменная является "приватной" для того класса, из которой мы её вызываем;
            int p_id = p.get_point_id(); // <- однако если есть публичный метод, который возвращает значение переменной "point_id", мы можем использовать его;
            Point p3 = new Point(5, 7); // <- создаем экземпляр, и если у него есть явный конструктор, то мы можем, допустим, задать значения экземпляру сразу при создании;
            Point p4 = new Point(y: 5, x: 7); // <- именованные параметры во всей своей красе;
            Console.WriteLine(p4.get_point_id()); // <- т.к. переменная "point_id" нам недоступна извне, мы обращаемся к нашему специально созданному методу;
            p4.ColorID = 5; // <- задаем значение для приватной переменной "color_id" через "getsetter" "ColorID";
            Console.WriteLine(p4.ColorID); // <- получаем значение из приватной переменной "color_id" через "getsetter" "ColorID";

            // this.something(); <- мы не можем использовать ключевое слово "this" внутри "static" методов;
            // Ведь с его помощью мы определяем наш конкретный экземпляр класса, однако "static" функции могут выполняться без создания отдельного экземпляра;
        }


    }


    // --Ключевое слово "static"--
    // --Статические поля класса--
    // --Статические методы--
    // --Статические свойства--

    class NewClass
    {
        public int a; // = 0;
        public static int b; // = 0;

        public void print_a() // <- можем вызвать данный метод только при наличии отдельного экземпляра класса;
        {
            Console.WriteLine(a);
        }

        public void print_ab()
        {
            Console.WriteLine(a);
            Console.WriteLine(b); // <- мы можем получить значение "static" переменной в "не-static" методе;
        }

        public static void print_b() // <- можем вызвать данный метод, обращаясь напрямую к классу;
        {
            Console.WriteLine(b);
            // Console.WriteLine(a); <- однако мы не можем в "static" методе получить значение "не-static" переменной...
            // т.к. для этого нам необходим экземпляр класса;
        }

        public NewClass() // <- обычный конструктор, который используется при создании нового экземпляра класса;
        {                 // Может использоваться перегрузка столько, сколько понадобится;
        }

        static NewClass() // <- статический конструктор, и он может быть только один;
        // static NewClass(int b) <- он также не может принимать никаких входных параметров;
        { // Он применяется только один раз и только в том случае, когда мы ПЕРВЫЙ раз пытаемся взаимодействовать/обращаться к классу;
          // Он также вызывается ПЕРЕД обычными конструкторами;
            b = 4; // <- можем взаимодействовать со статическими переменными;
            // a = 3; <- однако не можем взаимодействовать с не-статическими переменными;
            print_b(); // <- можем вызывать статические методы;
            // print_a(); <- однако не можем вызывать не-статические методы;
        }
    }

    class AnotherClass
    {
        static void Main()
        {
            NewClass new_class1 = new NewClass();
            NewClass new_class2 = new NewClass();
            new_class1.a = 3; // <- если переменная не является "static", то у каждого экземпляра класса может быть свое значение этой переменной;
            new_class2.a = 5; // <- если мы зададим в "new_class2" свое значение "a", оно не перекроет значение "a" класса "new_class1";
            Console.WriteLine(new_class1.a); // = 3;
            Console.WriteLine(new_class2.a); // = 5;

            // new_class1.b = 7; <- задать значение статической переменной через экземпляр не получится;
            NewClass.b = 7; // <- необходимо делать это вызывая сам необходимый нам класс;

            // Console.WriteLine(new_class1.b); <- соответсвенно, получить значение через экземпляр тоже не выйдет;
            Console.WriteLine(NewClass.b); // <- нужно делать это вызывая необходимый нам класс;

            // NewClass.print_a(); <- мы не можем вызывать "не-static" методы, не имея экземпляра класса;
            new_class1.print_a(); // <- вызываем "не-static" метод через экземпляр класса;

            // new_class1.print_b(); <- мы не можем вызывать "static" методы через экземпляра класса;
            NewClass.print_b(); // <- вызываем "static" метод напрямую обращаясь к классу;
        }
    }


    // --Статический класс--

    static class CoolClass
    {
        public static int a = 0; // <- внутри статического класса мы можем создавать статические переменные...
        public static void write_hello() // <- как и статические переменные; 
        {
            Console.WriteLine("Hello!");
            // this.a = 2; <- мы не можем использовать ключевое слово "this" в статических классах;
        }
        // public void write_goodbye() { } <- однако мы не можем создавать не-статические методы, т.к. для их использования необходим экземпляр класса;
        // Если хорошо подумать, то можно прийти к тому, что мы не можем создать экземпляр статического класса, т.к. он на то и статический;
        // public int b = 0;  <- мы также не можем создавать не-статические переменные;
        static CoolClass() { } // <- можем использовать статический конструктор;
        //public CoolClass() { } <- но не можем использовать обычный конструктор, т.к. он предназначен для не-статических классов;
    }

    class AnotherCoolClass
    {
        static void Main()
        {
            // CoolClass cool_class = new CoolClass(); <- мы не можем создать экземпляр статического класса;
            CoolClass.write_hello(); 

        }
    }


    // --Extension методы--
    // --Методы расширения--
    // --Расширяющие методы--

    class JustForFun
    {
        static void Main()
        {
            DateTime currentDateTime = DateTime.Now; 
            currentDateTime.Print(); // <- метод "Print()" не является встроенным методом, мы его создали самостоятельно ниже;
            DateTime.Now.Print(); // <- более простая альтернатива вызова метода, так тоже будет работать;
            DateTime.Now.IsDayOfWeek(DayOfWeek.Monday); // <- мы также можем вводить параметры, если заранее об этом позаботимся;
        }
    }

    static class MyExtensions
    {
        public static void Print(this DateTime dateTime) // <- используя ключевое слово "this" и указывая тип, для которого мы хотим создать расширение;
        {
            Console.WriteLine(dateTime.ToString());
        }
        public static bool IsDayOfWeek(this DateTime dateTime, DayOfWeek dayOfWeek) // <- в случае, если нам необходимо указать переменные...
        {                                        // То сначала мы указываем тип, для которого пишется расширение, а потом уже наши переменные;
            return dateTime.DayOfWeek == dayOfWeek;
        }
    }
}

namespace ConsoleApp2
{
    class JustForLulz
    {
        static void Main()
        {
            DateTime currentDateTime = DateTime.Now;
            // currentDateTime.Print(); -> мы не можем использовать расширения из другого пространства имен, или же другого "namespace";
            // Для того, чтобы иметь такую возможность, необходимо будет написать в самом верху "using <namespace_name>";
        }
    }


    // --Partial классы--

    partial class HotClass // <- благодаря ключевому слову "partial" мы можем хранить весь класс в абсолютно разных файлах;
    {
        static void Main()
        {
            PrintHelloWorld(); // <- мы видим здесь, что других методов у класса "HotClass" нет;
            // Мы можем вызвать данный метод, т.к. он находится в том же классе, просто вынесен в отдельный файл "Class.cs";
        }
    }


    // --const и readonly--

    class Aboba
    {
        public const int a = 4; // "const" переменную нельзя изменить, это константа - незыблемая и нерушимая;
        // Значение, которое должна хранить переменная, определяется еще ДО компиляции, т.е. хард-кодом, и мы не можем задать его во время выполнения программы;
        // public const int b; <- константе ОБЯЗАТЕЛЬНО необходимо значение, нельзя так просто объявить такую переменную и оставить;
        public readonly int b; // <- "readonly" блокирует изменение переменной, как только получает значение;
        // Именно поэтому мы можем объявить его, не вписывания определенное значение, в отличие от "const";
        public static readonly int c; // статическая переменная с "readonly", которую потом можно использовать, не создавая экземпляр класса;

        public Aboba(int _b) // <- обычный конструктор класса;
        {
            b = _b; // <- спокойно задаем значение переменной с "readonly", в дальнейшем его нельзя будет изменить;
        }
        public void Bebra(int _b)
        {
            //b = _b; <- мы не можем задать значение переменной с "readonly" вне конструктора класса;
        }
        static void Main()
        {
            // a = 5; -> если мы откомментируем обратно, компилятор выдаст нам ошибку, т.к. это константа;
            Console.WriteLine(a); // <- мы можем считать значение константы в любой удобный момент;
            // Console.WriteLine(b); <- мы не можем так просто считать значение переменной с "readonly", т.к. для этого нам нужен экземпляр класса;
            Aboba sus = new Aboba(3);
            Console.WriteLine(sus.b); // <- мы создали экземпляр класса, сразу задали значение для переменной "b" и можем его считать;
            Console.WriteLine(c); // <- данная переменная с "readonly" является статической, поэтому мы можем считать её значение не создавая экземпляр класса;
        }
    }


    // --Синтаксис инициализация объектов класса--

    class Amogus // Создаем обычный класс...
    {
        public int a; // с совершенно обычными переменными;
        public int b;
        public int c;
        public Amogus() {} // Создаем пустой конструктор...
        public Amogus(int a, int b) // А также конструктор, через который мы можем задать значения для переменных "a" и "b" при создании элемента класса;
        {
            this.a = a;
            this.b = b;
        }
    }
    class Bebs
    {
        static void Main()
        {
            Amogus sus = new Amogus(3, 5); // <- помимо того, что мы можем создать конструктор...
            Amogus sas = new Amogus() { a = 2, b = 7, c = 10 }; // <- мы можем использовать следующий синтаксис, чтобы задать значения и без создания конструктора;
            // Как видишь, в конструкторе даже нет переменной "c", а через этот синтаксис мы смогли задать её значение;
            // Это равносильно тому, чтобы сделать буквально следующее:
            Amogus ses = new Amogus();
            ses.a = 2;
            ses.b = 7;
            ses.c = 10;
        }
    }


    // --Наследование--

    class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public void PrintName()
        {
            Console.WriteLine($"My name is {FirstName} {LastName}");
        }
    }
    class Student : Person // <- мы можем унаследовать другой класс, чтобы перенять от него переменные и методы;
    {
        public string Education { get; set; }
        public void PrintEducation()
        {
            Console.WriteLine($"I study at {Education}");
        }
    }
    sealed class BadPerson : Person // <- с помощью ключевого слова "sealed" мы "запечатываем" класс и не даем его наследовать;
    {
        public void PrintBad()
        {
            Console.WriteLine($"I'm really bad guy;");
        }
    }
    // class GoodPerson : BadPerson { } <- если откомментировать это обратно, то компилятор выдаст ошибку;
    // Логично, ведь мы "запечатали" класс "BadPerson", и теперь ни "Student", ни "GoodPerson", ни еще какие-либо другие классы не могут его наследовать;

    class DoSomething
    {
        static void Main()
        {
            Person person = new Person() { FirstName = "Giovanni", LastName = "Giorgio" }; // <- создаем экземпляр класса и задаем значения;
            person.PrintName(); // <- выведет сообщение "My name is Giovanni Giorgio" в консоль;
            Student student = new Student() { FirstName = "Vasya", LastName = "Pupkin", Education = "Moscow State University" }; // <- т.к. класс "Student"...
            // унаследован от "Person", то класс "Student" также имеет переменные "FirstName" и "LastName";
            student.PrintName(); // <- выведет сообщение "My name is Vasya Pupkin" в консоль, т.к. класс "Student" также и унаследовал метод "PrintName()";
            student.PrintEducation(); // <- выведет сообщение "I study at Moscow State University", ибо мы создали данный метод внутри класса "Student";
        }
    }


    // --Наследование, конструкторы класса и ключевое слово "base"--

    class Vector2
    {
        public Vector2(int x, int y) // <- создаем конструктор для класса "Vector2", в который мы ОБЯЗАТЕЛЬНО должны получить параметры при создании экземпляра;
        {
            this.x = x;
            this.y = y;
            Console.WriteLine("Вызван конструктор класса Vector2");
        }
        public int x { get; set; }
        public int y { get; set; }
        public void PrintVector2() // <- обычный метод, который выводит в консоль переменные "x" и "y";
        {
            Console.WriteLine("X: " + x);
            Console.WriteLine("Y: " + y);
        }
    }

    class Vector3 : Vector2
    {
        public Vector3(int x, int y, int z) : base(x, y) // <- создаем конструктор для класса "Vector3", и т.к. у "родительского" класса...
            // имеется конструктор, в который мы ОБЯЗАТЕЛЬНО должны внести параметры, мы используем ключевое слово "base" и вводим туда параметры;
            // Таким образом, мы "отправляем" родительскому классу, какие-то значения, которые ему нужны;
        {
            this.z = z;
            Console.WriteLine("Вызван конструктор класса Vector3");
        }
        public int z { get; set; }
        public void PrintVector2() 
        {
            Console.WriteLine("You picked the wrong house fool!");
        }
        public void PrintVector3()
        {
            base.PrintVector2(); // <- явно указываем, что нам нужен метод именно из "родительского" класса. Функционал схож с ключевым словом "this";
            // В данном контекста его применение абсолютно не оправдано, тут скорее пример из разряда "смотри какая фича есть";
            Console.WriteLine("Z: " + z);
        }
    }

    class SwedishMeatballs
    {
        static void Main()
        {
            Vector3 vector3 = new Vector3(3, 5, 10); // <- мы создали новый экземпляр класса "Vector3", и сейчас произойдет две интересных вещи;
            // Во-первых, в консоль выведет сообщение "Вызван конструктор класса Vector2";
            // Во-вторых, в консоль выведет сообщение "Вызван конструктор класса Vector3";
            // Т.к. класс "Vector3" был унаследован от класса "Vector2", то создав экземпляр класса "Vector3"...
            // Мы вызываем конструкторы и класса "Vector2", и класса "Vector3";
            // Обрати внимание, что сначала был вызван конструктор класса "Vector2", а потом уже "Vector3", т.е. соблюдается цепочка наследования;
        }
    }





}
